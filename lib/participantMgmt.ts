import {
    PrismaClient,
    // Import the enum *object* generated by Prisma, renaming it
    Startclass as PrismaStartclassEnum
} from '@prisma/client';

const prisma = new PrismaClient();

// Define your application-level Startclass type, ensuring it aligns with Prisma's
export type StartclassKKFN = 'M채nnlich' | 'Weiblich';

export type ResultKKFN = {
    boulders: boolean[];
    lastUpdateTime: string | null;
};

export type ParticipantKKFN = {
    id: string;
    name: string;
    registrationDate: Date;
    secret: string;
    startclass: StartclassKKFN;
    results: ResultKKFN;
};


// Helper to cast Prisma participant to your application type
function toParticipantKKFN(participant: any): ParticipantKKFN {
    let parsedResults = participant.results;
    if (typeof parsedResults === 'string') {
        try { parsedResults = JSON.parse(parsedResults); }
        catch (e) {
             console.error("Failed to parse results JSON from DB", e);
             parsedResults = { boulders: Array(35).fill(false), lastUpdateTime: null };
        }
    }
    return {
        ...participant,
        startclass: participant.startclass as StartclassKKFN,
        results: parsedResults as ResultKKFN,
    };
}


// Type definitions to match your requirements
export type Result = {
    Route1: {
        zone: number
        attempts: number
    },
    Route2: {
        zone: number
        attempts: number
    },
    Route3: {
        zone: number
        attempts: number
    },
    Route4: {
        zone: number
        attempts: number
    },
    Route5: {
        zone: number
        attempts: number
    },
    Route6: {
        zone: number
        attempts: number
    },
    Route7: {
        zone: number
        attempts: number
    },
    Route8: {
        zone: number
        attempts: number
    },
}

export type Participant = {
    id: string
    name: string
    registrationDate: Date
    secret: string
    startclass: "Maennlich" | "Weiblich" | "Maennlich_Ue40" | "Weiblich_Ue40"
    results: Result
}

// Get all participants
export async function getAllParticipants(): Promise<ParticipantKKFN[]> {
    const participants = await prisma.participant.findMany();
    return participants.map(toParticipantKKFN);
}

// Export other functions to be used in API routes
export async function createParticipant(
    name: string,
    startclass: StartclassKKFN, // Input is still 'M채nnlich' or 'Weiblich'
    secret: string
): Promise<ParticipantKKFN> {
    const initialBoulders = Array(35).fill(false);
    const initialResults: ResultKKFN = {
        boulders: initialBoulders,
        lastUpdateTime: null,
    };

    // Map the incoming string to the actual Prisma Enum Member
    const prismaStartclassValue = startclass === 'M채nnlich'
        ? PrismaStartclassEnum.Maennlich // Use the imported enum object member
        : PrismaStartclassEnum.Weiblich; // Use the imported enum object member

    try {
        const participant = await prisma.participant.create({
            data: {
                name,
                // Pass the explicit enum member
                startclass: prismaStartclassValue,
                secret,
                registrationDate: new Date(),
                results: initialResults as any, // Keep cast for JSON
            },
        });
        return toParticipantKKFN(participant);
    } catch (error) {
         console.error("Error during prisma.participant.create:", error);
         // Rethrow or handle appropriately - the caller expects null on failure
         throw error; // Let the API route handle the 500 error
    }
}

export async function getParticipantById(id: string): Promise<ParticipantKKFN | null> {
    const participant = await prisma.participant.findUnique({
        where: { id },
    });

    if (!participant) return null;

    return toParticipantKKFN(participant);
}

export async function updateParticipantBoulderResult(
    id: string,
    boulderIndex: number, // 0-34
    completed: boolean,
    secretFromRequest: string // For verification
): Promise<ParticipantKKFN | null> {
    const participantFromDb = await prisma.participant.findUnique({
        where: { id },
    });

    if (!participantFromDb) {
        console.error("Participant not found for ID:", id);
        return null;
    }

    // Verify the secret
    if (participantFromDb.secret !== secretFromRequest) {
        console.error("Invalid secret for participant ID:", id);
        return null; // Authorization failure
    }

    // Ensure results is an object, not a string
    let currentResults: ResultKKFN;
    if (typeof participantFromDb.results === 'string') {
        try {
            currentResults = JSON.parse(participantFromDb.results) as ResultKKFN;
        } catch (e) {
             console.error("Failed to parse current results for participant:", id, e);
             // Initialize with default if corrupt, though this shouldn't happen ideally
             currentResults = { boulders: Array(35).fill(false), lastUpdateTime: null };
        }
    } else {
         currentResults = participantFromDb.results as unknown as ResultKKFN;
    }

    // Ensure boulders array exists and has the correct length
    if (!currentResults.boulders || currentResults.boulders.length !== 35) {
        console.warn(`Participant ${id} has malformed boulder results. Re-initializing.`);
        currentResults.boulders = Array(35).fill(false);
    }


    const newBoulders = [...currentResults.boulders];

    if (boulderIndex < 0 || boulderIndex >= newBoulders.length) {
        console.error("Invalid boulder index:", boulderIndex);
        return null; // Or throw new Error("Invalid boulder index");
    }
    newBoulders[boulderIndex] = completed;

    const updatedResultsData: ResultKKFN = {
        ...currentResults, // Preserve any other potential future fields in results
        boulders: newBoulders,
        lastUpdateTime: new Date().toISOString(),
    };

    const updatedParticipant = await prisma.participant.update({
        where: { id },
        data: {
            results: updatedResultsData as any, // Prisma expects Json input
        },
    });

    return toParticipantKKFN(updatedParticipant);
}

export async function getParticipantsByStartclass(startclass: StartclassKKFN): Promise<ParticipantKKFN[]> {
    // Map the incoming string to the actual Prisma Enum Member
   const prismaStartclassValue = startclass === 'M채nnlich'
       ? PrismaStartclassEnum.Maennlich // Use the imported enum object member
       : PrismaStartclassEnum.Weiblich; // Use the imported enum object member

   const participants = await prisma.participant.findMany({
       where: {
           // Use the explicit enum member in the where clause
           startclass: prismaStartclassValue
       },
   });
   return participants.map(toParticipantKKFN);
}

export async function deleteParticipantById(id: string): Promise<boolean> {
    try {
        await prisma.participant.delete({
            where: { id },
        });
        return true;
    } catch (error) {
        console.error('Error deleting participant:', error);
        return false;
    }
}


export async function verifyParticipantCredentials(
    name: string,
    secret: string
): Promise<ParticipantKKFN | null> {
    try {
        const participantsFromDb = await prisma.participant.findMany({
            where: {
                name: {
                    // Using equals for exact match, or contains if you prefer partial
                    equals: name,
                    mode: 'insensitive' // if your DB supports it for equals
                }
            }
        });

        if (!participantsFromDb || participantsFromDb.length === 0) {
            return null;
        }

        const verifiedParticipantFromDb = participantsFromDb.find(
            (p) => p.secret === secret
        );

        if (!verifiedParticipantFromDb) return null;

        return toParticipantKKFN(verifiedParticipantFromDb);
    } catch (error) {
        console.error('Error verifying participant credentials:', error);
        return null;
    }
}

/**
 * Get participants by name
 * @param name Participant name
 * @returns Array of participants with matching name
 */
export async function getParticipantsByName(name: string): Promise<ParticipantKKFN[]> {
    try {
        const participants = await prisma.participant.findMany({
            where: {
                name: {
                    contains: name,
                    mode: 'insensitive'
                }
            }
        });
        return participants.map(toParticipantKKFN);
    } catch (error) {
        console.error('Error fetching participants by name:', error);
        return [];
    }
}